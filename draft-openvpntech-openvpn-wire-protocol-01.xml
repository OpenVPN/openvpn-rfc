<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
    There has to be one entity for each item to be referenced.
    An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC2104 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml">
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2629 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2629.xml">
<!ENTITY RFC3552 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC5226 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY RFC5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC5280 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml">
]>
<!-- give errors regarding ID-nits and DTD validation -->
<?rfc strict="yes" ?>
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<?rfc tocdepth="2"?>
<!-- control references -->
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc symrefs="yes"?>
<!-- sort the reference entries alphabetically -->
<?rfc sortrefs="yes" ?>
<!-- control vertical white space
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- keep one blank line between list items -->
<?rfc subcompact="no" ?>
<!-- end of list of popular I-D processing instructions -->

<rfc category="info" docName="draft-openvpntech-openvpn-wire-protocol-01" ipr="trust200902">
 <!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN"
    they will automatically be output with "(if approved)" -->

 <front>
    <title abbrev="OpenVPN Wire Protocol">OpenVPN Wire Protocol</title>
    <author fullname="David Sommerseth" initials="D." surname="Sommerseth">
      <organization>OpenVPN Technologies, Inc</organization>
      <address>
        <email>david.sommerseth@openvpn.net</email>
      </address>
    </author>

    <author fullname="Steffan Karger" initials="S." surname="Karger">
      <organization>Fox-IT</organization>
      <address>
        <email>steffan.karger@fox-it.com</email>
      </address>
    </author>

    <date year="2016"/> <!-- Can add day="XX" month="YYY" later on -->

    <keyword>OpenVPN</keyword>
    <keyword>protocol</keyword>

    <abstract>
      <t>
        OpenVPN is an open source SSL/TLS based VPN solution which had
        its first release in May 2001.  This document describes the wire
        protocol OpenVPN makes use of for establishing end-to-end-
        connections.  Even though OpenVPN bases its communication on
        SSL/TLS, it is not a traditional SSL/TLS protocol which utilizes
        only TCP.  OpenVPN supports some enhanced security features as
        well as providing SSL/TLS connections both over TCP as well as
        UDP.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>
        OpenVPN is an open source SSL/TLS based VPN soltion which was
        first released in 2001.  The communication between OpenVPN
        instances are based on SSL/TLS but it has added several
        additional features on top of the standard SSL/TLS protocol.
        The wire protocol this document describes will go into the
        depths of how OpenVPN processes communicates with each other.
      </t>
      <t>
        The wire protocol is dynamic, which means it will be slightly
        different depending on which features the OpenVPN processes have
        been configured to use.  New implementations SHOULD implement all
        features.
      </t>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref target="RFC2119">RFC 2119</xref>.</t>
      </section>

    </section>

    <section title="The OpenVPN Wire Protocol">
      <t>
        Since OpenVPN can work both in a traditional server-client setup
        as well as a peer-to-peer setup, this document tries to avoid the
        concept of server and clients.  It will be refered to these as
        either the local or remote sites.  In a peer-to-peer setup only
        a single tunnel can be established, while in a server-client setup
        several clients can connect to a single server at the same time.
      </t>

      <section title="TCP and UDP transport modes">
        <t>
          OpenVPN is capable of using both UDP and TCP for transporting
          SSL/TLS traffic.  The SSL/TLS protocol is strictly written for
          TCP but OpenVPN makes that possible through encapsulating the
          SSL/TLS packets and adding a reliability layer to avoid issues
          when packets gets resent.
        </t>
        <t>
          The wire packet identical for both transport modes with one
          exception.  The TCP packets carry a 16 bits packet length
          indicator of the size of the rest of the packet.  This indicator
          is for a single TCP packet.  If the payload packet to be transported
          is too big to fit into a single TCP packet, it will be split into
          several individual packets where the length indicator is per
          individual packet.
        </t>
      </section>

      <section title="Peer-to-peer and TLS operational modes">
        <section title="Peer-to-peer mode">
        <t>
          The OpenVPN protocol can be used both for site-to-site
          configurations which does not make use of any TLS features, so
          called peer-to-peer mode.  In this mode there is no control
          channel and all the data on the wire is plain encrypted packets
          transported over a standard UDP or TCP connection.
        </t>
        <t>
          Due to the restriction of not having a control channel in
          peer-to-peer mode the protocol, it is not possible to add any
          particular authentication methods.  It is also not possible to
          transport any configuration parameters over the wire.
        </t>
        <t>
          Peer-to-peer mode also depends on a shared secret key between
          both ends of the VPN tunnel.  Again, as there are no SSL/TLS
          handshakes between either side, this method does not have any
          possibilties to enable Perfect Forward Secrecy (PFS).  The
          data channel is encrypted solely by the shared static secret.
          This mode does not negotiate any ephemeral session keys for the
          tunnelled data.
        </t>
        </section>

        <section title="TLS mode">
        <t>
          With TLS mode the control channel gets activated and this
          requires both sides to make use of private keys and
          <xref target="RFC5280">X.509</xref> Certificates.  These requirements are due to this
          operational mode utilizing the  <xref target="RFC5246">TLS/SSL</xref> protocol
          This mode is also the only operational mode which uses the
          client-server terminology in OpenVPN.
        </t>
        <t>
          The use of X.509 certificates on the client side is OPTIONAL
          and it is REQUIRED on the server side.  It is highly RECOMMENDED
          to always enable user/password authentication when X.509
          client certificates is not used.
        </t>
        <t>
          It is highly RECOMMENDED to enforce certificate authentication
          against a locally controlled Certificate Authority (CA) certificate.
        </t>
        <t>
          [FIXME: explain more what happens on the wire during the
                  SSL/TLS handshake and certificate authentication]
        </t>
        <t>
          The TLS mode will use the same communication channel for
          both TLS handshakes and the tunnel data.  The TLS handshakes
          is referred to as the control channel and tunnel data is
          referred to as the data channel.  Each packet in TLS mode,
          contains an OPCODE which defines if the following payload is
          a control channel or data channel packet.
        </t>
        </section>
      </section>

      <section title="HMAC authentication of control channel packets">
        <t>
          <xref target="RFC2104">HMAC authentication</xref> enables an
          additional authentication on the packet level.  HMAC
          authentication is only possible with TLS mode and will only
          impact the control channel.  The data channel is already
          protected by HMAC authentication embedded in the SSL/TLS
          payload.
        </t>
        <t>
          This authentication can strengthen the overall security on
          both client and server side as OpenVPN will validate the HMAC
          signature before it is sent to the SSL/TLS layer for decryption.
          This can protect server and client from SSL/TLS protocol
          issues from all users not having access to a valid HMAC key.
        </t>
        <t>
          The keys used for HMAC signatures are static and shared between
          server and all clients.  The default hashing algorithm is HMAC-SHA1
          but any hashing algorithms supported by the SSL/TLS protocol can
          be used as long as the clients and server uses the same algorithm.
          The choice of hashing algorithms defines the length of the HMAC
          field in the control packet.  HMAC-SHA1 uses 20 bytes, HMAC-SHA512
          uses 64 bytes.
        </t>

        <section title="HMAC authentication subkeys">
          <t>
            HMAC packet authentication requires two independent and
            preshared static keys for the authentication.  One key
            is used for signing packets and the other key is used
            to verify signatures from the remote side.  The OpenVPN
            terminology for this is key-direction.  The key-direction
            defines which set of keys is used for signing and for
            verification.  Alle clients MUST use the same
            key-direction while the server MUST use the oposite
            key-direction.
          </t>
        </section>
      </section>

      <section title="Packet replay protection">
        <t>TBD</t>
      </section>

      <section title="Pushing configuration options and OCC">
        <t>
          TBD
        </t>
      </section>

    </section>

    <section title="Communictaion channels">
      <t>
        OpenVPN communictates over two channels which are multiplexed over the
        same connection; control channel and data channel.  The control
        channel is used for passing configuration and environment data between
        each side of the tunnel, including encryption session keys.  The data
        channel carries the encrypted tunnel data.  The OPCODE determines which
        channel the packet belongs to.
      </t>

      <section title="Overview of OPCODEs">
        <t>
          Each packet MUST contain an OPCODE.  This is located within the first
          byte in each UDP packet and the third byte in TCP packets.  The high 5
          bits contains the OPCODE and the lower 3 bits defines a key-id.  The
          OPCODE defines the contents of the following payload.
        </t>
        <texttable>
          <ttcol>OPCODE</ttcol>
          <ttcol>Channel</ttcol>
          <ttcol>Short name</ttcol>
          <ttcol>Status</ttcol>

          <c>1</c>
          <c>Control</c>
          <c>CONTROL_HARD_RESET_CLIENT_V1</c>
          <c>Obsolete</c>

          <c>2</c>
          <c>Control</c>
          <c>CONTROL_HARD_RESET_SERVER_V1</c>
          <c>Obsolete</c>

          <c>3</c>
          <c>Control</c>
          <c>CONTROL_SOFT_RESET_V1</c>
          <c>Current</c>

          <c>4</c>
          <c>Control</c>
          <c>CONTROL_V1</c>
          <c>Current</c>

          <c>5</c>
          <c>Control</c>
          <c>ACK_V1</c>
          <c>Current</c>

          <c>6</c>
          <c>Data</c>
          <c>DATA_V1</c>
          <c>Current</c>

          <c>7</c>
          <c>Control</c>
          <c>CONTROL_HARD_RESET_CLIENT_V2</c>
          <c>Current</c>

          <c>8</c>
          <c>Control</c>
          <c>CONTROL_HARD_RESET_SERVER_V2</c>
          <c>Current</c>

          <c>9</c>
          <c>Data</c>
          <c>DATA_V2</c>
          <c>Current</c>
        </texttable>
      </section>

      <section title="The Control Channel">
        <t>
          The control channel is used to pass configuration and environment
          information in addition to handle the SSL/TLS handshake process
          between the server and client.
        </t>

        <section title="Control channel wire packet structure">
          <t>
            The following table lists all fields found in control channel
            packets.  The fields arrive in the order they are listed in the
            table.
          </t>
          <t>
            The  TCP/UDP column indicates if the corresponding field is present
            when using TCP and/or UDP as transport protocol.  When the TLS mode
            column contains an X it means the field is used when the connection
            is a server/clients based connection.  These fields are not used in
            Peer-to-Peer connections.
          </t>
          <t>
            The TLS auth column indicates fields used when additional
            HMAC authentication data is added to the control channel packets
          </t>
          <texttable>
            <ttcol>Field name</ttcol>
            <ttcol align="right">Length (bits)</ttcol>
            <ttcol align="center">TCP/UDP</ttcol>
            <ttcol align="center">TLS mode</ttcol>
            <ttcol align="center">TLS auth</ttcol>
            <ttcol>Comment</ttcol>

            <c>pkt_len</c>
            <c>16</c>
            <c>TCP</c>
            <c></c>
            <c></c>
            <c>Packet length</c>

            <c>OPCODE</c>
            <c>5</c>
            <c>TCP/UDP</c>
            <c>X</c>
            <c></c>
            <c></c>

            <c>key_id</c>
            <c>3</c>
            <c>TCP/UDP</c>
            <c>X</c>
            <c></c>
            <c></c>

            <c>session_id</c>
            <c>64</c>
            <c>TCP/UDP</c>
            <c>X</c>
            <c></c>
            <c></c>

            <c>HMAC</c>
            <c>128-512</c>
            <c>TCP/UDP</c>
            <c>X</c>
            <c>X</c>
            <c>Algorithm defines length</c>

            <c>packet_id</c>
            <c>32</c>
            <c>TCP/UDP</c>
            <c>X</c>
            <c>X</c>
            <c></c>

            <c>timestamp</c>
            <c>32</c>
            <c>TCP/UDP</c>
            <c>X</c>
            <c>X</c>
            <c>OPTIONAL</c>

            <c>payload</c>
            <c>(var)</c>
            <c>TCP/UDP</c>
            <c>*</c>
            <c>*</c>
            <c>REQUIRED</c>
          </texttable>

        </section>

        <section title="Control Channel OPCODEs">
          <section title="[OPCODE ID 1] CONTROL_HARD_RESET_CLIENT_V1">
            <t>
              OBSOLETE: This OPCODE is not in use any more.
            </t>
            <t>
              This MAY be reused in the future once all other OPCODE
              locations have been used.
            </t>
          </section>

          <section title="[OPCODE ID 2] CONTROL_HARD_RESET_SERVER_V1">
            <t>
              OBSOLETE: This OPCODE is not in use any more.
            </t>
            <t>
              This MAY be reused in the future once all other OPCODE
              locations have been used.
            </t>
          </section>

          <section title="[OPCODE ID 3] CONTROL_SOFT_RESET_V1">
            <t>
              New key, graceful transition from old to new
            </t>
            <t>
              This is used to rotate session keys.  It enables both
              a new key and the old ones to be valid for a limited time
              window.
            </t>
            <t>
              Either client or server CAN send a CONTROL_SOFT_RESET_V1
              packet to the remote side.  The remote side MUST respond
              with a CONTROL_SOFT_RESET_V1 message to acknowledge that
              a renegotiation of the session keys will start.  Then
              the side receiving the last CONTROL_SOFT_RESET_V1 packet
              replies with a ACK_V1 message.  At this point the
              renegotation can start using the CONTROL_V1 OPCODE.
            </t>
            <t>
              When the ACK_V1 packet is being sent, the key_id field
              MUST be incremented to ensure the connection can still
              use the old keys for a shorter time until the transistion
              has completed.  Any following packets need to use the new
              key-id until the old key have been removed and the new
              key-id replaces it completely.
            </t>
            <t>
              [FIXME: Elaborate more on how re-keying happens]
            </t>
          </section>

          <section title="[OPCODE ID 4] CONTROL_V1">
            <t>
              Control channel packet, usually TLS protocol data
            </t>
            <t>
              CONTROL_V1 is used to encapsulate the SSL/TLS protocol into the
              OpenVPN wire packet, primarily used for the SSL/TLS handshake
              process.  The payload of CONTROL_V1 packets are expected to be
              processed by an SSL/TLS library.  Once the SSL/TLS handshake
              have completed and the ephemeral session key have been
              negotiated, encrypted tunnel data will use either DATA_V1 or
              DATA_V2 for the transport of those packets.
            </t>
          </section>

          <section title="[OPCODE ID 5] ACK_V1">
            <t>
              Acknowledgement for received control channel packets
            </t>
            <t>
              When control channel packets have been received an ACK_V1
              packet is sent back to confirm its arrival.  It SHOULD NOT
              be sent an ACK_V1 message upon receiving an ACK_V1 message.
            </t>
          </section>

          <section title="[OPCODE ID 7] CONTROL_HARD_RESET_CLIENT_V2">
            <t>
              Initial key from client, forget previous state
            </t>
            <t>
              The client starts with a fresh new session key.  This tells the server
              to initiate a new TLS handshake and establish a new session key for
              data channel going from client to server.
            </t>
          </section>

          <section title="[OPCODE ID 8] CONTROL_HARD_RESET_SERVER_V2">
            <t>
              Initial key from server, forget previous state.
            </t>
            <t>
              [FIXME: TBD]
              Similar to CONTROL_HARD_RESET_CLIENT_V2, but initiated from
              the server side.
            </t>
          </section>
        </section>
        <section title="PUSH messages">
        </section>

        <section title="Peer-Info">
        </section>
      </section>

      <section title="The Data Channel">
        <section title="[OPCODE ID 6] DATA_V1">
          <t>
            Data channel packet, 1-byte header
          </t>
          <t>
            The table below describes each field and the order of the fields
            found in DATA_V1 packets.
          </t>
          <texttable>
            <ttcol>Field name</ttcol>
            <ttcol align="right">Length (bits)</ttcol>
            <ttcol>Description</ttcol>

            <c>op_code</c>
            <c>5</c>
            <c>Must always be DATA_V1</c>

            <c>key_id</c>
            <c>3</c>
            <c></c>

            <c>payload</c>
            <c>(var)</c>
            <c>Encrypted data including HMAC</c>
          </texttable>
        </section>

        <section title="[OPCODE ID 9] DATA_V2">
          <t>
            Data channel packet with 4-byte header.  This is
            similar to DATA_V1 with an additional field of 24 bits
            for Peer-ID.
          </t>
          <t>
            The table below describes each field and the order of the fields
            found in DATA_V2 packets.
          </t>
          <texttable>
            <ttcol>Field name</ttcol>
            <ttcol align="right">Length (bits)</ttcol>
            <ttcol>Description</ttcol>

            <c>op_code</c>
            <c>5</c>
            <c>Must always be DATA_V2</c>

            <c>key_id</c>
            <c>3</c>
            <c></c>

            <c>peer_id</c>
            <c>24</c>
            <c>Peer-ID of the client.  0xFFFFFF disables Peer-ID.</c>

            <c>payload</c>
            <c>(var)</c>
            <c>Encrypted data including HMAC</c>
          </texttable>
        </section>
      </section>
    </section>

    <section title="Peer-ID">
      <t>
        The Peer-ID implementation is optional.  The purpose of this feature
        is to allow a client to float between various client IP addresses and
        UDP ports.  When a client floats it means that the established
        encryption and session keys will be reused when the client's source IP
        address or source port changes.  Reasons for such changes can be NAT
        firewalls interrupting longer lasting established connections, mobile
        devices moving from WLAN to a mobile data carrier (such as GPRS, 3G,
        LTE, etc) and similar scenarios.
      </t>
      <section title="Requirements">
        <t>
          Each client implementing Peer-ID support MUST support the IV_PROTO=2
          wire protocol and MUST indicate this to the server through the
          peer-info response.   By sending IV_PROTO=2 to the server, it means
          the client will be able to use the DATA_V2 packet format.  When
          the server acknowledges that the client supports IV_PROTO=2/DATA_V2
          it SHOULD assign a unique Peer-ID to the client.  The server is
          responsible of keeping track of which Peer-ID is related to which
          active session and MUST ensure no active clients share the same
          Peer-ID.
        </t>
        <t>
          Clients MUST accept the peer-id option being passed to it via a
          PUSH_REPLY message and SHOULD use this value as the Peer-ID in all
          DATA_V2 packets.  Clients MUST provide a valid Peer-ID in all
          DATA_V2 packets, but it can be the ID used to indicate Peer-ID being
          disabled.
        </t>
        <t>
          Server implementations MUST support the IV_PROTO=2 and the DATA_V2
          packet format and MUST evaluate the response from the client before
          assigning and pushing a peer-id option to the client.  The server
          can use both DATA_V1 and DATA_V2 packet formats when communicating
          with the clients.  If the server chooses to use DATA_V2, the server
          MUST use the disabled Peer-ID reference to the client.
        </t>
        <t>
          The client is not expected to parse the Peer-ID in DATA_V2 packets.
          Currently the behaviour of Peer-ID provided by the server to client
          is undetermined.
        </t>
        <t>
          The Peer-ID is implictly protected via the HMAC signature added to
          all DATA_V2 packets.
        </t>
      </section>
      <section title="Disabling Peer-ID">
        <t>
          The client can disable the Peer-ID feature by ignoring the server
          provided Peer-ID and using value 0xFFFFFF instead.  The server is
          currently expected to always use 0xFFFFFF when it sends DATA_V2
          packets to clients.
        </t>
      </section>
      <section title="Allowing floating clients">
        <t>
          The server MUST ensure the packet integrity is intact, through
          checking HMAC or GCM authentication tags, replay protection, etc
          of the DATA_V2 packet
        </t>
        <t>
          In addition the server MUST ensure the float does not clobber
          a pre-existing client, such as a the client floating to a source
          IP address used by a different client unless it can be verified
          that the pre-existing client is a previous instance of the
          floating client.

          [FIXME: Verify.  What if several independent clients float to same source IP?]
        </t>
      </section>
    </section>

    <section title="Cryptography">
      <section title="OpenVPN and the SSL/TLS protocol">
        <t>TBD</t>
      </section>

      <section title="Cipher negotiation">
        <t>TBD</t>
      </section>

      <section title="TLS mode and PKI">
        <t>TBD</t>
      </section>
    </section>

    <section title="User authentication">
      <section title="User/password authentication">
        <t>TBD</t>
      </section>

      <section title="Challenge-Response authentication">
        <t>TBD</t>
      </section>

    </section>
  </middle>

  <back>
   <references title="Normative References">
     <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml"?-->
     &RFC2104;

     <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
     &RFC2119;

     <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml"?-->
     &RFC5246;

     <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml"?-->
     &RFC5280;
   </references>
  </back>
</rfc>
