<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
    There has to be one entity for each item to be referenced.
    An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC2104 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml">
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2629 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2629.xml">
<!ENTITY RFC3552 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC5226 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY RFC5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC5280 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml">
]>
<!-- give errors regarding ID-nits and DTD validation -->
<?rfc strict="yes" ?>
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<?rfc tocdepth="2"?>
<!-- control references -->
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc symrefs="yes"?>
<!-- sort the reference entries alphabetically -->
<?rfc sortrefs="yes" ?>
<!-- control vertical white space
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- keep one blank line between list items -->
<?rfc subcompact="no" ?>
<!-- end of list of popular I-D processing instructions -->

<rfc category="info" docName="draft-openvpntech-openvpn-wire-protocol-01" ipr="trust200902">
 <!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN"
    they will automatically be output with "(if approved)" -->

 <front>
    <title abbrev="OpenVPN Wire Protocol">OpenVPN Wire Protocol</title>
    <author fullname="David Sommerseth" initials="D." surname="Sommerseth">
      <organization>OpenVPN Technologies, Inc</organization>
      <address>
        <email>david.sommerseth@openvpn.net</email>
      </address>
    </author>

    <author fullname="Steffan Karger" initials="S." surname="Karger">
      <organization>Fox-IT</organization>
      <address>
        <email>steffan.karger@fox-it.com</email>
      </address>
    </author>

    <date year="2016"/> <!-- Can add day="XX" month="YYY" later on -->

    <keyword>OpenVPN</keyword>
    <keyword>protocol</keyword>

    <abstract>
      <t>
        OpenVPN is an open source SSL/TLS based VPN solution which had
        its first release in May 2001.  This document describes the wire
        protocol OpenVPN makes use of for establishing end-to-end-
        connections.  Even though OpenVPN bases its communication on
        SSL/TLS, it is not a traditional SSL/TLS protocol which utilizes
        only TCP.  OpenVPN supports some enhanced security features as
        well as providing SSL/TLS connections both over TCP as well as
        UDP.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>
        OpenVPN is an open source SSL/TLS based VPN soltion which was
        first released in 2001.  The communication between OpenVPN
        instances are based on SSL/TLS but it has added several
        additional features on top of the standard SSL/TLS protocol.
        The wire protocol this document describes will go into the
        depths of how OpenVPN processes communicates with each other.
      </t>
      <t>
        The wire protocol is dynamic, which means it will be slightly
        different depending on which features the OpenVPN processes have
        been configured to use.  New implementations SHOULD implement all
        features.
      </t>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref target="RFC2119">RFC 2119</xref>.</t>
      </section>

    </section>

    <section title="The OpenVPN Wire Protocol">
      <t>
        Since OpenVPN can work both in a traditional server-client setup
        as well as a peer-to-peer setup, this document tries to avoid the
        concept of server and clients.  It will be refered to these as
        either the local or remote sites.  In a peer-to-peer setup only
        a single tunnel can be established, while in a server-client setup
        several clients can connect to a single server at the same time.
      </t>

      <section title="Generic wire packet structure">
        <figure>
          <artwork><![CDATA[
+---------+---------+--------+------------+------+~
| pkt_len | op_code | key_id | session_id | HMAC |~
+---------+---------+--------+------------+------+~

  ~+-----------+-----------+---------+
  ~| packet_id | timestamp | payload |
  ~+-----------+-----------+---------+
        ]]></artwork>
        </figure>

        <t>
          These fields represents all possible features in OpenVPN.  Not
          all of them are necessarily in use in all configurations.  Below
          is a table describing when to expect these different fields:
        </t>
        <texttable>
          <ttcol>Field name</ttcol>
          <ttcol align="right">Length (bits)</ttcol>
          <ttcol align="center">TCP/UDP</ttcol>
          <ttcol align="center">TLS mode</ttcol>
          <ttcol align="center">TLS auth</ttcol>
          <ttcol>Comment</ttcol>

          <c>pkt_len</c>
          <c>16</c>
          <c>TCP</c>
          <c></c>
          <c></c>
          <c>Packet size</c>

          <c>op_code</c>
          <c>5</c>
          <c>TCP/UDP</c>
          <c>X</c>
          <c></c>
          <c></c>

          <c>key_id</c>
          <c>3</c>
          <c>TCP/UDP</c>
          <c>X</c>
          <c></c>
          <c></c>

          <c>session_id</c>
          <c>64</c>
          <c>TCP/UDP</c>
          <c>X</c>
          <c></c>
          <c></c>

          <c>HMAC</c>
          <c>128-160</c>
          <c>TCP/UDP</c>
          <c>X</c>
          <c>X</c>
          <c></c>

          <c>packet_id</c>
          <c>32</c>
          <c>TCP/UDP</c>
          <c>X</c>
          <c>X</c>
          <c></c>

          <c>timestamp</c>
          <c>32</c>
          <c>TCP/UDP</c>
          <c>X</c>
          <c>X</c>
          <c>OPTIONAL</c>

          <c>payload</c>
          <c>(var)</c>
          <c>TCP/UDP</c>
          <c>*</c>
          <c>*</c>
          <c>REQUIRED</c>

        </texttable>
        <t>
          An OpenVPN wire packet constists of a control channel packet and
          a data channel packet and is multiplexed by the OpenVPN process.
          The control channel packet is responsible for the TLS/SSL
          establishing, passing configuration paramters between the local
          and the remote site and other management and control parameters.
          The data channel packet (payload) is the encrypted network data
          to be passed between the local and remote site.
        </t>
      </section>

      <section title="TCP and UDP transport modes">
        <t>
          OpenVPN is capable of using both UDP and TCP for transporting
          SSL/TLS traffic.  The SSL/TLS protocol is strictly written for
          TCP but OpenVPN makes that possible through encapsulating the
          SSL/TLS packets and adding a reliability layer to avoid issues
          when packets gets resent.
        </t>
        <t>
          The wire packet identical for both transport modes with one
          exception.  The TCP packets carry a 16 bits packet length
          indicator of the whole packet to be read. [FIXME: Verify statement]
        </t>
      </section>

      <section title="TLS and peer-to-peer modes">
        <section title="Peer-to-peer mode">
        <t>
          The OpenVPN protocol can be used both for site-to-site
          configurations which does not make use of any TLS features, so
          called peer-to-peer mode.  In this mode there is no control
          channel  [FIXME: Verify statement] and all the data on the wire is the encrypted network
          traffic.
        </t>
        <t>
          Due to the restriction of not having a control channel in
          peer-to-peer mode the protocol, it is not possible to add any
          particular authentication methods.  It is also not possible to
          transport any configuration parameters over the wire.
        </t>
        <t>
          Peer-to-peer mode also depends on a shared secret key between
          both ends of the VPN tunnel.  Again, as there is are no SSL/TLS
          handshakes between either side, this method does not have any
          possibilties to enable Perfect Forward Secrecy (PFS).  The
          data channel is encrypted solely by the shared secret.
        </t>
        </section>

        <section title="TLS mode">
        <t>
          With TLS mode the control channel gets activated and this
          requires both sides to make use of private keys and
          <xref target="RFC5280">X.509</xref> Certificates.  These requirements are due to this
          operational mode utilizing the  <xref target="RFC5246">TLS/SSL</xref> protocol
          This mode is also the only operational mode which uses the
          client-server terminology in OpenVPN.
        </t>
        <t>
          The use of X.509 certificates on the client side is OPTIONAL
          and it is REQUIRED on the server side.  It is highly RECOMMENDED
          to always enable user/password authentication when X.509
          client certificates is not used.
        </t>
        <t>
          It is highly RECOMMENDED to enforce certificate authentication
          against a locally stored Certificate Authority (CA) certificate.
        </t>
        <t>
          [FIXME: explain more what happens on the wire during the
                  SSL/TLS handshake and certificate authentication]
        </t>
        </section>
      </section>

      <section title="HMAC packet authentication">
        <t>
           <xref target="RFC2104">HMAC authentication</xref> enables an additional authentication on
          the packet level.  HMAC authentication is only possible with
          the TLS mode enabled, as it extends the control channel with
          additional fields.  This HMAC authentication comes on top of
          the HMAC processing already present in the SSL/TLS protocol.
        </t>
        <t>
          This authentication can strengthen the overall security on
          both client and server side as OpenVPN will validate the HMAC
          signature before it is sent to the SSL/TLS layer for decryption.
          This can protect server and client from SSL/TLS protocol
          issues from all users not having access to a valid HMAC key.
        </t>
        <t>
          The keys used for HMAC signatures are static and shared between
          server and all clients.  The signature being added is based on
          a SHA1 hash of ... [FIXME: verify and extend; what about --auth? is MD5 really supported nowadays?]
        </t>
        <t>
          The field for the HMAC signature is restricted to be between 128
          and 160 bits long.  For SHA1 based signatures it will be 160 bits.
        </t>

        <section title="HMAC authentication subkeys"> <!-- FIXME: improve langauge all over -->
          <t>
            This packet authentication requires two keys, each key being
            160 bits long [FIXME: Verify statement].
          </t>
          <t>
            In OpenVPN terminology, which key each sides uses is
            defined by the key-direction.  All clients MUST use the
            same key (key-direction) and the server MUST use the
            other key when signing packets it is going to send.
          </t>
          <t>
            As both sides have both keys, it will use the other
            key (reverse key-direction) for verifying the senders
            HMAC signature.
          </t>
        </section>
      </section>

      <section title="Packet replay protection">
        <t>TBD</t>
      </section>

      <section title="Pushing configuration options and OCC">
        <t>
          TBD
        </t>
      </section>

    </section>

    <section title="Communictaion channels">
      <t>
        OpenVPN communictates over two channels which are multiplexed over the
        same connection; control channel and data channel.  The control
        channel is used for passing configuration and environment data between
        each side of the tunnel, including encryption session keys.  The data
        channel carries the encrypted tunnel data.  The OPCODE determins which
        channel the packet belongs to.
      </t>

      <section title="The OPCODE">
        <t>
          Each packet should contain an OPCODE at a predictalbe possition
          within each packet.  This defines which information records to be
          expected on the wire.

          The OPCODE is found as the first 5 bits of the first OpenVPN wire packet.
        </t>
        <texttable>
          <ttcol>OPCODE</ttcol>
          <ttcol>Channel</ttcol>
          <ttcol>Short name</ttcol>
          <ttcol>Status</ttcol>

          <c>1</c>
          <c>Control</c>
          <c>CONTROL_HARD_RESET_CLIENT_V1</c>
          <c>Obsolete</c>

          <c>2</c>
          <c>Control</c>
          <c>CONTROL_HARD_RESET_SERVER_V1</c>
          <c>Obsolete</c>

          <c>3</c>
          <c>Control</c>
          <c>CONTROL_SOFT_RESET_V1</c>
          <c>Current</c>

          <c>4</c>
          <c>Control</c>
          <c>CONTROL_V1</c>
          <c>Current</c>

          <c>5</c>
          <c>Control</c>
          <c>ACK_V1</c>
          <c>Current</c>

          <c>6</c>
          <c>Data</c>
          <c>DATA_V1</c>
          <c>Current</c>

          <c>7</c>
          <c>Control</c>
          <c>CONTROL_HARD_RESET_CLIENT_V2</c>
          <c>Current</c>

          <c>8</c>
          <c>Control</c>
          <c>CONTROL_HARD_RESET_SERVER_V2</c>
          <c>Current</c>

          <c>9</c>
          <c>Data</c>
          <c>DATA_V2</c>
          <c>Current</c>
        </texttable>
      </section>

      <section title="The Control Channel">
        <t>
          The control channel is used to pass configuration and environment
          information between the server and client.
        </t>

        <section title="[OPCODE ID 1] CONTROL_HARD_RESET_CLIENT_V1">
          <t>
            Initial key from client, forget previous state
            [ TODO: Find out when it was deprecated ]
          </t>
        </section>

        <section title="[OPCODE ID 2] CONTROL_HARD_RESET_SERVER_V1">
          <t>
            Initial key from server, forget previous state
            [ TODO: Find out when it was deprecated ]
          </t>
        </section>

        <section title="[OPCODE ID 3] CONTROL_SOFT_RESET_V1">
          <t>
            New key, graceful transition from old to new
          </t>
        </section>

        <section title="[OPCODE ID 4] CONTROL_V1">
          <t>
            Control channel packet, usually TLS cipher text
          </t>
        </section>

        <section title="[OPCODE ID 5] ACK_V1">
          <t>
            Ackknowledgement for received packets
          </t>
        </section>

        <section title="[OPCODE ID 7] CONTROL_HARD_RESET_CLIENT_V2">
          <t>
            Initial key from client, forget previous state
          </t>
        </section>

        <section title="[OPCODE ID 8] CONTROL_HARD_RESET_SERVER_V2">
          <t>
            Initial key from server, forget previous state.
          </t>
        </section>

        <section title="PUSH messages">
        </section>

        <section title="Peer-Info">
        </section>
      </section>

      <section title="The Data Channel">
        <section title="[OPCODE ID 6] DATA_V1">
          <t>
            Data channel packet, 1-byte header
          </t>
        </section>

        <section title="[OPCODE ID 9] DATA_V2">
          <t>
            Data channel packet with 4-byte header.  The lower 24 bits
            are used for Peer-ID.
          </t>
        </section>
      </section>
    </section>

    <section title="Peer-ID">
      <t>
        The Peer-ID implementation is optional.  The purpose of this feature
        is to allow a client to float between various client IP addresses and
        UDP ports.  When a client floats it means that the established
        encryption and session keys will be reused when the client's source IP
        address or source port changes.  Reasons for such changes can be NAT
        firewalls interrupting longer lasting established connections, mobile
        devices moving from WLAN to a mobile data carrier (such as GPRS, 3G,
        LTE, etc) and similar scenarios.
      </t>
      <section title="Requirements">
        <t>
          Each client implementing Peer-ID support MUST support the IV_PROTO=2
          wire protocol and MUST indicate this to the server through the
          peer-info response.   By sending IV_PROTO=2 to the server, it means
          the client will be able to use the DATA_V2 packet format.  When
          the server acknowledges the client supports IV_PROTO=2/DATA_V2 it
          SHOULD assign a unique Peer-ID to the client.  The server is
          responsible of keeping track of which Peer-ID is related to which
          active session.
        </t>
        <t>
          Clients MUST accept the peer-id option being passed to it via a
          PUSH_REPLY message and SHOULD use this value as the Peer-ID in all
          DATA_V2 packets.  Clients MUST provide a valid Peer-ID in all
          DATA_V2 packets, but it can be the ID used to indicate Peer-ID being
          disabled.
        </t>
        <t>
          Server implementations MUST support the IV_PROTO=2 and the DATA_V2
          packet format and MUST evaluate the response from the client before
          assigning and pushing a peer-id option to the client.  The server
          can use both DATA_V1 and DATA_V2 packet formats when communicating
          with the clients.  If the server chooses to use DATA_V2, it MUST
          use the disabled Peer-ID reference to the client.
        </t>
        <t>
          The client is not expected to parse the Peer-ID in DATA_V2 packets.
          Currently the behaviour of Peer-ID provided by the server to client
          is undetermined.
        </t>
        <t>
          The Peer-ID is implictly protected via the HMAC signature added to
          all DATA_V2 packets.
        </t>
      </section>
      <section title="Disabling Peer-ID">
        <t>
          The client can disable the Peer-ID feature by ignoring the server
          provided Peer-ID and using value 0xFFFFFF instead.  The server is
          currently expected to always use 0xFFFFFF when it sends DATA_V2
          packets to clients.
        </t>
      </section>
      <section title="Allowing floating clients">
        <t>
          The server MUST ensure the packet integrity is intact, through
          checking HMAC or GCM authentication tags, replay protection, etc
          of the DATA_V2 packet
        </t>
        <t>
          In addition the server MUST ensure the float does not clobber
          a pre-existing client, such as a the client floating to a source
          IP address used by a different client unless it can be verified
          that the pre-existing client is a previous instance of the
          floating client.

          [FIXME: Verify.  What if several independent clients float to same source IP?]
        </t>
      </section>
      <section title="DATA_V2 and Peer-ID in the wire packet">
        <figure>
          <artwork><![CDATA[
+---------+---------+---------+---------+
| op_code | key_id  | peer_id | payload |
+---------+---------+---------+---------+
]]></artwork>
        </figure>
        <texttable>
          <ttcol>Field name</ttcol>
          <ttcol align="right">Length (bits)</ttcol>
          <ttcol>Description</ttcol>

          <c>op_code</c>
          <c>5</c>
          <c>Must always be DATA_V2 (integer value 9)</c>

          <c>key_id</c>
          <c>3</c>
          <c></c>

          <c>peer_id</c>
          <c>24</c>
          <c>Peer-ID of the client.  If set to 0xFFFFFF Peer-ID functionality is disabled</c>

          <c>payload</c>
          <c>(var)</c>
          <c>Encrypted data including HMAC</c>
        </texttable>
      </section>
    </section>

    <section title="Cryptography">
      <section title="OpenVPN and the SSL/TLS protocol">
        <t>TBD</t>
      </section>

      <section title="Cipher negotiation">
        <t>TBD</t>
      </section>

      <section title="TLS mode and PKI">
        <t>TBD</t>
      </section>
    </section>

    <section title="User authentication">
      <section title="User/password authentication">
        <t>TBD</t>
      </section>

      <section title="Challenge-Response authentication">
        <t>TBD</t>
      </section>

    </section>
  </middle>

  <back>
   <references title="Normative References">
     <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml"?-->
     &RFC2104;

     <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
     &RFC2119;

     <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml"?-->
     &RFC5246;

     <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml"?-->
     &RFC5280;
   </references>
  </back>
</rfc>
